import datetime
import io
import logging
from typing import Optional

import feedparser
import numpy
import numpy as np
from django.contrib.postgres.fields import ArrayField
from django.db import models
from django.utils.translation import gettext_lazy as _
from newsplease import NewsPlease

from failures.networks.models import (
    Embedder,
    QuestionAnswerer,
    Summarizer,
    ZeroShotClassifier,
)

from failures.parameters.models import Parameter


class SearchQuery(models.Model):
    keyword = models.CharField(
        _("Keyword"),
        max_length=255,
        help_text=_("Keyword to use for searching for news articles."),
    )

    start_year = models.IntegerField(
        _("Start Year"),
        null=True,
        blank=True,
        help_text=_(
            "News articles will be searched from this year onwards. This field is optional."
        ),
    )

    end_year = models.IntegerField(
        _("End Year"),
        null=True,
        blank=True,
        help_text=_(
            "News articles will be searched until this year. This field is optional."
        ),
    )

    created_at = models.DateTimeField(
        _("Created At"),
        auto_now_add=True,
        help_text=_("Date and time when this search query was created."),
        editable=False,
    )

    last_searched_at = models.DateTimeField(
        _("Last Searched At"),
        null=True,
        blank=True,
        help_text=_("Date and time when this search query was last searched."),
        editable=False,
    )

    sources = ArrayField(
        models.URLField(max_length=255),
        blank=True,
        null=True,
        verbose_name=_("Sources"),
        help_text=_("Sources to search for news articles, such as nytimes.com,wired.com."),
    )

    class Meta:
        verbose_name = _("Search Query")
        verbose_name_plural = _("Search Queries")

    def __str__(self):
        return f"{self.keyword}"


class Article(models.Model):
    failures = models.ManyToManyField(
        "Failure",
        related_name="articles",
        related_query_name="article",
        verbose_name=_("Failures"),
    )

    search_queries = models.ManyToManyField(
        SearchQuery,
        related_name="articles",
        related_query_name="article",
        verbose_name=_("Search Queries"),
    )

    # TODO: Change arbitrary max_length constraints
    title = models.CharField(
        _("Title"), max_length=510, help_text=_("Title of the article.")
    )

    # Marking url as unique=True because we don't want to store the same article twice
    url = models.URLField(
        _("URL"), unique=True, max_length=510, help_text=_("URL of the article.")
    )

    published = models.DateTimeField(
        _("Published"), help_text=_("Date and time when the article was published.")
    )

    source = models.URLField(
        _("Source"),
        help_text=_("URL of the source of the article, such as nytimes.com."),
    )

    summary = models.TextField(
        _("Summary"),
        blank=True,
        help_text=_("Summary of the article generated by a summarizer model."),
    )

    body = models.TextField(
        _("Body"), blank=True, help_text=_("Body of the article scraped from the URL.")
    )

    embedding = models.FileField(
        _("Embedding"),
        upload_to="embeddings",
        null=True,
        help_text=_("NumPy array of the embedding of the article stored as a file."),
        editable=False,
    )

    scraped_at = models.DateTimeField(
        _("Scraped at"),
        auto_now_add=True,
        help_text=_("Date and time when the article was scraped."),
        editable=False,
    )

    describes_failure = models.BooleanField(
        _("Describes Failure"),
        null=True,
        help_text=_(
            "Whether the article describes a failure. This field is set by a human or the classifier."
        ),
    )

    describes_failure_confidence = models.FloatField(
        _("Describes Failure Confidence"),
        null=True,
        help_text=_(
            "Confidence of the classifier in whether the article describes a failure."
        ),
    )

    class Meta:
        verbose_name = _("Article")
        verbose_name_plural = _("Articles")

    def __str__(self):
        return self.title

    def has_manual_annotation(self) -> bool:
        return self.failures.filter(manual_annotation=True).exists()

    @classmethod
    def create_from_google_news_rss_feed(
        cls,
        search_query: SearchQuery,
    ):
        url = cls.format_google_news_rss_url(
            search_query.keyword,
            search_query.start_year,
            search_query.end_year,
            search_query.sources,
        )
        articles = []
        feed = feedparser.parse(url)
        search_query.last_searched_at = datetime.datetime.now()
        search_query.save()
        for entry in feed.entries:
            # TODO: reduce queries here
            if not cls.objects.filter(url=entry.link).exists():
                article = cls.objects.create(
                    title=entry["title"],
                    url=entry["link"],
                    # example: Mon, 24 Oct 2022 11:00:00 GMT
                    published=datetime.datetime.strptime(
                        entry["published"], "%a, %d %b %Y %H:%M:%S %Z"
                    ),
                    source=entry["source"]["href"],
                )
                logging.info("Created article: %s.", article)
            else:
                article = cls.objects.get(url=entry.link)
            logging.info(
                f"Adding search query to article: %s - %s.", article, search_query
            )
            article.search_queries.add(search_query)
            article.save()
            articles.append(article)
        return articles

    # TODO: should this method be on SearchQuery?
    @staticmethod
    def format_google_news_rss_url(
        keyword: str,
        start_year: Optional[int] = None,
        end_year: Optional[int] = None,
        sources: Optional[list[str]] = None,
    ) -> str:
        keyword = keyword.replace(" ", "%20")
        url = f"https://news.google.com/rss/search?q={keyword}"
        if start_year:
            url += f"%20after%3A{start_year}-01-01"
        if end_year:
            url += f"%20before%3A{end_year}-01-01"
        for i, source in enumerate(sources):
            if i > 0:
                url += "%20OR"
            url += f"%20site%3Ahttps%3A%2F%2F{source}"
        url += "&hl=en-US&gl=US&ceid=US%3Aen"
        return url

    def scrape_body(self):
        try:
            article = NewsPlease.from_url(self.url)
        except Exception as e:
            logging.error(f"Failed to scrape article %s: %s.", self, e)
            return
        if article.maintext is None:
            logging.error("Failed to scrape article %s: No text found.", self)
            return
        self.body = article.maintext
        self.save()
        logging.info(f"Scraped body for %s.", self)
        return self.body

    def summarize_body(self, summarizer: Summarizer):
        self.summary: str = summarizer.run(self.body)
        self.save()
        return self.summary

    def create_embedding(self, embedder: Embedder):
        embedding = embedder.run(self.body)
        bytes_io = io.BytesIO()
        numpy.save(bytes_io, embedding)
        self.embedding.save("embedding.npy", bytes_io)
        self.save()
        return self.embedding

    def cosine_similarity(self, other: "Article") -> float:
        if self.embedding is None or other.embedding is None:
            raise ValueError("One or both articles have no embedding.")
        embedding_one = numpy.load(self.embedding.path)
        embedding_two = numpy.load(other.embedding.path)
        return np.dot(embedding_one, embedding_two) / (
            np.linalg.norm(embedding_one) * np.linalg.norm(embedding_two)
        )

    def classify_as_failure(self, classifier: ZeroShotClassifier):
        prediction: tuple[str, float] = classifier.run(self.body)
        self.describes_failure = classifier.labels.index(prediction[0]) == 0
        self.describes_failure_confidence = prediction[1]
        self.save()
        return self.describes_failure


class FailureCause(models.Model):
    failure = models.ForeignKey(
        "Failure",
        related_name="failure_causes",
        related_query_name="failure_cause",
        on_delete=models.CASCADE,
        verbose_name=_("Failure"),
    )

    description = models.TextField(_("Description"))

    class Meta:
        verbose_name = _("Failure Cause")
        verbose_name_plural = _("Failure Causes")

    def __str__(self):
        return self.description


class Failure(models.Model):
    class Duration(models.TextChoices):
        TRANSIENT = "TRANSIENT", _("Transient")
        PERMANENT = "PERMANENT", _("Permanent")
        INTERMITTENT = "INTERMITTENT", _("Intermittent")

    class Location(models.TextChoices):
        INTERNAL = "INTERNAL", _("Internal")
        EXTERNAL = "EXTERNAL", _("External")

    class Semantics(models.TextChoices):
        CRASH = "CRASH", _("Crash")
        OMISSION = "OMISSION", _("Omission")
        TIMING = "TIMING", _("Timing")
        VALUE = "VALUE", _("Value")
        ARBITRARY = "ARBITRARY", _("Arbitrary")

    class Behavior(models.TextChoices):
        SOFT = "SOFT", _("Soft")
        HARD = "HARD", _("Hard")

    class Dimension(models.TextChoices):
        SOFTWARE = "SOFTWARE", _("Software")
        HARDWARE = "HARDWARE", _("Hardware")

    name = models.CharField(_("Name"), max_length=255)

    description = models.TextField(_("Description"))

    started_at = models.CharField(_("Started at"), max_length=255)

    ended_at = models.CharField(_("Ended at"), max_length=255)

    created_at = models.DateTimeField(_("Created at"), auto_now_add=True)

    # manual_annotation=False means that the failure was automatically detected
    manual_annotation = models.BooleanField(_("Manual Annotation"), default=False)

    # display means that this failure should be displayed in the UI, because it has been merged with other failures
    display = models.BooleanField(_("Display"), default=False)

    industry = models.CharField(_("Industry"), max_length=255)

    duration = models.CharField(
        _("Duration"),
        max_length=12,
        choices=Duration.choices,
        blank=True,
    )

    location = models.CharField(
        _("Location"),
        max_length=8,
        choices=Location.choices,
        blank=True,
    )

    semantics = models.CharField(
        _("Semantics"),
        max_length=9,
        choices=Semantics.choices,
        blank=True,
    )

    behavior = models.CharField(
        _("Behavior"),
        max_length=4,
        choices=Behavior.choices,
        blank=True,
    )

    dimension = models.CharField(
        _("Dimension"),
        max_length=8,
        choices=Dimension.choices,
        blank=True,
    )

    class Meta:
        verbose_name = _("Failure")
        verbose_name_plural = _("Failures")

    def __str__(self):
        return self.name

    @classmethod
    def create_from_article(
        cls,
        article: Article,
        question_answerer: QuestionAnswerer,
    ):
        failure = cls()

        failure.name = question_answerer.run(
            (Parameter.get("FAILURE_NAME_QUESTION", "What is the name of the software failure?"), article.body)
        )
        failure.industry = question_answerer.run(
            (Parameter.get("FAILURE_INDUSTRY_QUESTION", "What industry does this software failure belong to?"), article.body)
        )
        failure.started_at = question_answerer.run(
            (Parameter.get("FAILURE_STARTED_AT_QUESTION", "When did this software failure start?"), article.body)
        )
        failure.ended_at = question_answerer.run(
            (Parameter.get("FAILURE_ENDED_AT_QUESTION", "When did this software failure end?"), article.body)
        )
        failure.description = question_answerer.run(
            (Parameter.get("FAILURE_DESCRIPTION_QUESTION", "What is the description of the software failure?"), article.body)
        )
        failure.save()
        return failure
